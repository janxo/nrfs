
# Network Raid File System (Using FUSE)

პროექტი შედგება სამი ცალი executable-სგან

ესენია:

	net_raid_client
	fuse_client
	net_raid_server

net_raid_client-ს გადაეცემა კონფიგურაციის ფაილი,
რომელიც თვლის რამდენი STORAGE შეხვდა ამ ფაილში და იმის მიხედვით 
უშვებს შესაბამისი რაოდენობის fuse_client პროცესებს execve_თი.

fuse_client პროცესი თავის მხრივ პარსავს
და საჭირო ინფორმაციას ინახავს შემდეგ სტრუქტურაში (ყველა სტრუქტურა აღწერილია info.h-ში)


```c
typedef struct strg_info {
	char errorlog[NAME_LEN]; 		// ფაილის სახელი სადაც უნდა მოხდეს მესიჯების ლოგირება
	char cache_size[CACHE_LEN];		// ქეშის ზომა
	char cache_replacement[CACHE_LEN];	// cache-replacement ალგორითმის დასახელება
	int timeout;				// დრო რომლის განმავლობაშიც უნდა მოხდეს სევერთან კავშირის აღდგენის მცდელობა
	storage strg;				// ინფორმაცია ცალკეულ სანახზე
} strg_info_t;


typedef struct storage {			
	char diskname[NAME_LEN];		// დისკის დასახელება რითაც ხდება პარსერში დისკების რაოდენობის დათვლა
	char mountpoint[NAME_LEN];		// დასამაუნთებელი ფოლდერის სახელი
	int server_count;			// სერვერების რაოდენობა სადაც უნდა მოხდეს ფაილების შენახვა
	char raid;				// რეიდის ნომერი
	remote servers[MAX_SERVERS];		// სერვერების მასივი
	remote hotswap;				// სათადარიგო სერვერი
} storage;


typedef struct remote {
	char ip_address[ADDR_LEN];		// სერვერის მისამართი
	char port[PORT_LEN];			// სერვერის პორტი
} remote;
```

როგორც კი fuse_client მორჩება პარსვას, იწყებს სერვერებთან კავშირის დამყარებას და შემდეგ
იძახება fuse_main ფუნქცია რომელიც სტარტავს fuse-ს. მოქმედების პრინციპი შემდეგია.
fuse-ს ფუნქციებს, რომ მივაწოდოთ საჭირო ინფორმაცია ამისთვის მოთხოვნა უნდა გავგზავნოთ სერვერებზე
უნდა გამოვიძახოთ სერვერებზე შესაბამისი  sys_call-ები და საჭირო უნფორმაცია დავუბრუნოთ კლიენტს.
აუცილებელია რომ გამოგზავნილი ინფორმაცია წავიკითხოთ ზუსტად იმავე რაოდენობით რაც სერვერმა გამოგვიგზავნა.
არც მეტი და არც ნაკლები, წინააღმდეგ შემთხვევაში თუ ნაკლები წავიკითხეთ შეცდომით ინფორმაციას დააბრუენბს
fuse, ან შემდეგ სხვა სისტემ ქოლი წაიკითხავს იმ ინფორმაციას რაც მას არ ეკუთვნოდა და ის გაფუჭდება.



მოთხოვნისთვის ვიყენებ შემდეგ სტრუქტურას:
```c
typedef struct {
	int raid;		// რომელი რეიდია. ამის მიხედვით ხდება ჰენდლერების გამოძახება სერვერის მხარეს
	command fn;		// fuses ფუნქციები გადავნომრე enum ტიპით
	bool sendback;		// ამის მიხედვით იგებს სერვერი ინფორმაცია უნდა გაუგზავნოს თუ არა კლიენტს, მაგალითად ერთ სერვერს გაეგზავნება true, 								მეორეს false რომ ორივემ არ გააგზავნოს ტყუილად ინფორმაცია
	file_info f_info;	// ინფორმაცია ფაილზე
} request_t;


typedef struct file_info {
	char path[NAME_LEN];	// ფაილის რელაციური მისამართი
	int flags;		// ფაილის ფლეგები
	int fd;			// ფაილ დესკრიპტორი
	int mask;		// მასკი(სჭირდება ზოგიერთ სის-ქოლს)
	mode_t mode;		// მოუდი
	off_t f_size;		// ფაილის ჩანკის ზომა
	off_t offset;		// დაშორება სადაც უნდა მოხდეს წერა/კითხვა
	size_t padding_size;	// პედინგის ზომა(RAID5-სთვის)
} file_info;
```

სერვერი ციკლში ელოდება კლიენტისგან მესიჯს. წინასწარ ვიცით რომ request_t ტიპის ინფორმაცია მოუვა
და როგორ კი ამ ზომის ინფოს წაიკითხავს, ამოწმებს რომელი რეიდია, შემდეგ ამოწმებს ბრძანების ნომერს
და ამის მიხედვით იძახებს ჰენდლერს. ჰენდლერებს აქვთ ერთნაირი სტრუქტურა - void handler(int cfd, void *data);
გადმოეცემა კლიენტის სოკეტის ფაილ დესკრიპტორი და data რომელიც ჩვენ შემთხვევაში request_t * იქნება.

ამის შემდგომ უკვე ხდება სის-ქოლების ინდივიდუალური ჰენდლინგი.
