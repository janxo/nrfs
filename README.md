
# Network Raid File System (Using FUSE)

პროეტქი დაწერილია make-თი

კომპილაცია - make
გასუფთავება - make clean


პროექტი შედგება სამი ცალი executable-სგან

ესენია:
	net_raid_client
	fuse_client
	net_raid_server

net_raid_client-ს გადაეცემა კონფიგურაციის ფაილი,
რომელიც თვლის რამდენი "diskname" -სტრინგი შეხვდა ამ ფაილში და იმის მიხედვით 
უშვებს შესაბამისი რაოდენობის fuse_client პროცესებს exec_ით.

fuse_client პროცესი თავის მხრივ პარსავს
და საჭირო ინფორმაციას ინახავს შემდეგ სტრუქტურაში (ყველა სტრუქტურა აღწერილია info.h-ში)


```c
typedef struct strg_info {
	char errorlog[NAME_LEN]; 		// ფაილის სახელი სადაც უნდა მოხდეს მესიჯების ლოგირება
	char cache_size[CACHE_LEN];		// ქეშის ზომა
	char cache_replacement[CACHE_LEN];	// cache-replacement ალგორითმის დასახელება
	int timeout;				// დრო რომლის განმავლობაშიც უნდა მოხდეს სევერთან კავშირის აღდგენის მცდელობა
	storage strg;				// ინფორმაცია ცალკეულ სანახზე
} strg_info_t;


typedef struct storage {			
	char diskname[NAME_LEN];		// დისკის დასახელება რითაც ხდება პარსერში დისკების რაოდენობის დათვლა
	char mountpoint[NAME_LEN];		// დასამაუნთებელი ფოლდერის სახელი
	int server_count;			// სერვერების რაოდენობა სადაც უნდა მოხდეს ფაილების შენახვა
	char raid;				// რეიდის ნომერი
	remote servers[MAX_SERVERS];		// სერვერების მასივი
	remote hotswap;				// სათადარიგო სერვერი
} storage;


typedef struct remote {
	char ip_address[ADDR_LEN];		// სერვერის მისამართი
	char port[PORT_LEN];			// სერვერის პორტი
} remote;
```

როგორც კი fuse_client მორჩება პარსვას, იწყებს სერვერებთან კავშირის დამყარებას და შემდეგ
იძახება fuse_main ფუნქცია რომელიც სტარტავს fuse-ს. მოქმედების პრინციპი შემდეგია.
fuse-ს ფუნქციებს, რომ მივაწოდოთ საჭირო ინფორმაცია ამისთვის მოთხოვნა უნდა გავგზავნოთ სერვერებზე
უნდა გამოვიძახოთ სერვერებზე შესაბამისი  sys_call-ები და საჭირო უნფორმაცია დავუბრუნოთ კლიენტს.
აუცილებელია რომ გამოგზავნილი ინფორმაცია წავიკითხოთ ზუსტად იმავე რაოდენობით რაც სერვერმა გამოგვიგზავნა.
არც მეტი და არც ნაკლები, წინააღმდეგ შემთხვევაში პაკეტები აირევა და პროგრამა გაფუჭდება.


მოთხოვნისთვის ვიყენებ შემდეგ სტრუქტურას:
```c
typedef struct {
	int raid;		// რომელი რეიდია.
	command fn;		// fuses ფუნქციები გადავნომრე enum ტიპით, ამის მიხედვით ხდება ჰენდლერების გამოძახება სერვერის მხარეს
	bool sendback;		// ამის მიხედვით იგებს სერვერი ინფორმაცია უნდა გაუგზავნოს თუ არა კლიენტს, მაგალითად ერთ სერვერს გაეგზავნება true, მეორეს false რომ ორივემ არ გააგზავნოს ტყუილად ინფორმაცია
	file_info f_info;	// ინფორმაცია ფაილზე
} request_t;


typedef struct file_info {
	char path[NAME_LEN];	// ფაილის რელაციური მისამართი
	int flags;		// ფაილის ფლეგები
	int fd;			// ფაილ დესკრიპტორი
	int mask;		// ბიტ მასკი(სჭირდება ზოგიერთ სის-ქოლს)
	mode_t mode;		// მოუდი
	off_t f_size;		// ფაილის ჩანკის ზომა
	off_t offset;		// დაშორება სადაც უნდა მოხდეს წერა/კითხვა
	size_t padding_size;	// პედინგის ზომა(RAID5-სთვის)
} file_info;

typedef struct {
	int packet_size;
	status st;
	char buff[BUFF_len];
} response_t;
```

სერვერი ციკლში ელოდება კლიენტისგან მესიჯს. წინასწარ ვიცით რომ request_t ტიპის ინფორმაცია მოუვა
და როგორც კი ამ ზომის ინფოს წაიკითხავს, ამოწმებს რომელი რეიდია, შემდეგ ამოწმებს ბრძანების ნომერს
და ამის მიხედვით იძახებს ჰენდლერს. ჰენდლერებს აქვთ ერთნაირი სტრუქტურა - void handler(int cfd, void * data);
გადმოეცემა კლიენტის სოკეტის ფაილ დესკრიპტორი და data რომელიც ჩვენ შემთხვევაში request_t * იქნება. ამ სტრუქტურაში არის ფაილის
სახელი, რომელიც fuse-სგან რელაციურ მისამართად გვეძლევა. სერვერი თავისი მუშა ფოლდერის path-ს მიაწებებს ამ ფაილის სახელს და
ამის შემდგომ უკვე ხდება სის-ქოლების ინდივიდუალური ჰენდლინგი.

წერა/კითხვა ხდება writen/readn ფუნქციებით რომლებიც იმპლემენტირებულია utils.c-ში. ეს ფუნქციები იყნებენ write/read ფუნქციებსხ,
მაგრამ მათგან განსხვავებით უზრუნველყოფენ გადაცემული ზომის ინფორმაციის სრულად წაკითხვას, წინააღმდეგ შემთხვევაში აბრუნებენ error კოდს. თუ ერორ კოდი დაბრუნდა ნიშნავს, რომ სათანადო ზომის ინფორმაცია ვერ წაიკითხა, რაც იმის მანიშნებელია რომ სერვერი მოკვდა.

ფაილები ინახება ორ სერვერზე რომელიც გადანომრილია RAID_MAIN - 0  და RAID_REPLICANT(BR საპატივსაცემოდ) - 1.
პროგრამა მუშა მდგომარეობაშია თუ 2-დან ერთი სერვერი მაინც არის ცოცხალი. თუ ორივე სერვერი მუშაობს
ყველა სისტემ ქოლის მოთხოვნები იგზავნება თითოეულ სერვერზე read და readdir გარდა, რომელიც მხოლოდ მთავარ სერვერზე იგზავნება,
რათა ზედმეტი ინფორმაცია არ ვგზავნო და არ შევანელო მუშაობის პროცესი.

ჩაწერის მექანიზმი შემდეგია: თავდაპირველად ვგზავნი MAIN სერვერზე მოთხოვნას და იქიდან ველოდები პასუხს, სერვერი
პასუხს მატყობინებს status კოდით რომელიც enum ტიპისაა. სტატუს კოდის მიხედვით, თუ წარმატებით მოხდა ჩაწერა 
მოთხოვნა იგზავნება მეორე სერვერზე და იქიდანაც თუ დადებითი პასუხი მოვიდა, კლიენტს უბრუნდება პასუხი რომ ჩაწერა წარმატებით მოხდა, თუ არა და ბრუნდება შეცდომა.


ჰეშების დათვლისას პირველივე იდეა რაც მომაფიქრდა იყო დათვლა write ბრძანებისას, მაგრამ პრობლემას წავაწყდი, რადგანაც fuse 4096 ბაიტიანი ბაფერით წერს. მიზანი მთელი ფაილის ჰეშის შენახვაა და აქ კი გამოდიოდა რომ მხოლოდ ბოლოს ჩაწერილი ჰეში შეინახებოდა.
აქედან ერთი გამოსავალი იყო, ყოველი ჩაწერისას ფაილის ჰეში თავიდან დამეთვალა, რაც ძალიან ცუდია რადგან დათვლა მოხდება იმდენჯერ რამდენი write-ც დაჭირდება მთელი ფაილის ჩაწერას ანუ - (ფაილის ზომა)/(ბაფერის ზომა). ბოლოს უკეთეს ვარიანტზე შევჩერდი, ჰეშის release-ში დათვლა რომელიც write-ს შემეგ იძახება. ამ დროს ნიშნავს რომ მთელი ფაილი ბოლომდე ჩაიწერა და ჰეშის დათვლის სწორი დროა. release read-ის შემდეგაც იძახება და ამიტომ ამ დროს რომ არ მოხდეს ტყუილად დათვლა, ვამოწმებ წინა სისტემ ქოლი write იყო თუ არა.
	
მქონდა ვარიანტი კლიენტის მხარეს დამეთვალა და შემდეგ გამეგზავნა სერვერისთვის, მაგრამ ამ შემთხვევაში კლიენტის მხარეს დაითვლება არა მთელი ფაილის ჰეში, არამედ მხოლოდ მისი ნაწილის რომლის ჩაწერაც ახლა ხდება, რაც პრობლემაა, რადგან შეიძლება ამ ფაილში უკვე ეწეროს რაღაც, რაზეც წვდომა მხოლოდ სერვერს აქვს ამიტომაც ჰეშების დათვლა ხდება სერვერების მხარეს. ყველაფერი თუ კარგად შესრულდა ჰეშები შეინახება ფაილის extended attribute-ში.

ჰეშის დასათვლელად ვიყენებ OpenSSL ბიბლიოთეკის MD5-ს.

ჰეშების შემოწმება ხდება open sys-call-ის დროს. თუ ფაილს დასეტილი აქვს ატრიბუტად ჰეში, თავიდან ვითვლი ფაილის ჰეშს და ვადარებ დასეტილ ჰეშს. ამის მიხდვით ეგზავნება კლიენტს სტატუსი სერვერისგან, მოხდა თუ არა ჰეშების დამთხვევა და თუ მოდა დამთხვევა მაშინ ეგზავნება ჰეშიც, თუ არ მოხდა ჰეშების დამთხვევა ან ჯერ საერთოდ არ აქვს ატრიბუტი დასეტილი მაშინ უგზავნის რომ დამთხვევა არ მოხდა. კლიენტი იღებს ორივე სერვერიდან ინფორმაციას და აქვს 3 ვარიანტი:

1. პირველ სერვერზე ჰეში დაემთხვა დასეტილ ჰეშს და მეორეზე არა - ამ შემთხვევაში პირველ სერვერს ეგზავნება მოთხოვნა რომ მეორე 		სერვერზე გააგზავნოს მოცემული ფაილი. სერვერს ეგზავნება მეორე სერვერის იპ მისამართი და პორტი რათა დაუკავშირდეს მეორე 			სერვერს და გაუგზავნოს ფაილი. სერვერს ეგზავნება ჩაწერის მოთხოვნა იგივენაირად თითქოს კლიენტისგან მოსდის ბრძანება და შემდეგ ფაილის კონტენტის გაგზავნა ხდება sendfile ფუნქციით. 
2. მეორე სერვერზე ჰეში დაემთხვა დასეტილ ჰეშს და პირველზე არა - ამ შემთხვევაში იგივე მოთხოვნა ეგზავნება მერე სერვერს.
3. ორივე სერვერზე ჰეშები დაემთხვა ერთმანეთს - ამ შემთხვევაში ჰეშები დამატებით ერთმანეთს დარდება და თუ დამთხვევა არ მოხდა
	მაშინ ფაილის გაგზავნის მოთხოვნა ეგზავნება იმ სერვერს რომელზეც ფაილის ზომა უფრო დიდია.
	
## კავშირის წყვეტა

სერვერთან კავშირის წყვეტის აღმოჩენა ხდება თუ მასზე გაგზავნილი წერა/კითხვის მოთხოვნა დააბრუნებს -1. ამის შემოწმებას ვაკეთებ რამდენიმე ფუნქციაში ესენია: read/write, getattr, release, readdir, რომელთა გამოძახებაც ყველაზე ხშირად ხდება. ამის შემდეგ სრული დატვირთვა გადადის ცოცხალ სერვერზე და ამასთანავე ცალკე ნაკადში ხდება დაზიანებულ სერვერთან კავშირის აღდგენის მცდელობა config ფაილში მითითებული დროის ინტერვალის განმავლობაში. წყვეტის მომენტში მუშა სერვერზე შესაძლებელია ფაილების წერა და კითხვა.
თუ კავშირის აღდგენა მოხერხდა მაშინ ამ სერვერზე ფაილების აღდგენა მოხდება იმ შემთხვევაში როდესაც ამ ფაილების გახსნა მოხდება კლიენტის მიერ. (თუ MAIN სერვერთან მოხდა კავშირის გაწყვეტა მაშინ აღდგენისას ახალი ჩაწერილი ფაილები არ გამოჩნდება ls დროს, რადგან კითხვას ამ სერვერიდან ვაწარმოებთ, მაგრამ მაინც შეგვიძლია ამ ფაილების მოთხოვნა და ფაილები სერვერზე აღდგება ჩვეულებრივ).

იმ შემთხვევაში თუ მითითებულ დროის ინტერვალში ვერ მოდხდა კავშირის აღდგენა, საქმეში ერთვება hotswap სერვერი. ამ შემთხვევაში საჭიროა ყველა ფაილი რაც კი ცოცხალ სერვერზეა ამ სერვერზე დავადუბლიროთ. კლიენტი მუშა სერვერს უგზავნის cmd_restore_dir ფუნქციის ნომრით request-ს. სერვერ კი ჰენდლინგს აკეთებს restore1_dir_handler ფუნქციაში. fork-ით ახალ პროცესში ვიძახებ exec ფუნქციას რომელსაც tar პროგრამას გადავცემ და ვაარქივებ მთელ ფოლდერს. მშობელი პროცესი უცდის შვილის დასრულებას და შემდეგ დაარქივებულ ფაილს უგზავნის ახალ სერვერს, რომლის მისამართს და პორტსაც კლიენტი აწვდის. ახალი სერვერი თავის მხრივ იღებს ამ დაარქივებულ ფაილს და ცალკე პროცესში ამოოარქივებს. მშობელი პროცესი უცდის შვილის დასრულებას. პროცესის დასრულებისას იშლება არქივის ფაილი ორივე სერვერიდან.



კავშირის გაწყვეტა შეიძლება ბევრჯერ მოხდეს მაგრამ პროგრამა მაინც აგრძელებს მუშაობას ჩვეულ რეჟიმში, ასევე შეიძლება hotswap ჩანაცვლებაც ბევრჯერ მოხდეს შემდეგი პრინციპით - სერვერი რომელიც გაითიშა ცხადდება ახალ hotswap სერვერად, ანუ თუ გვაგქვს 3 სერვერი 0, 1 და 2. 0 და 1 მუშა სერვერებია,ხოლო 2 - hotswap. დავუშვათ გაითიშა 1 სერვერ, მისი ჩანაცვლება მოხდება 2 სერვერით, ხოლო სერვერი 1 გამოცდხადდება hotswap სერვერად. თუ მოხდა სერვერ 1 აღდგენა და რომელიმე მუშა გაითიშა მაშინ მისი ჩანაცვლება მოხდება სერვერ 1-ით. და ასე მრავალჯერ შეიძლება.


## ლოგირების მესიჯები

მოვლენები რომელიც შეიძლება მოხდეს

```c
#define MSG_RECONNECT "trying to reconnect"					// სერვერი ცდილობს კავშირის აღდგენას
#define MSG_RECONNECT_SUCCESS "reconnected successfully"	// კავშირის აღდგენა წარმატებით დასრულდა
#define MSG_RECONNECT_FAIL "reconnect attempt failed"		// კავშირის აღდგენა წარუატებლად დასრულდა
#define MSG_SERVER_LOST	"server declared as lost"			// სერვერი მოკვდა
#define MSG_HOTSWAP_INIT "trying to connect to hotswap"		// hotswap სერვერთან კავშირის დამყარების მცცდელობა
#define MSG_HOTSWAP_ADD "hotswap server added"				// hotswap სერვერთან კავშირი წარმატებით დამყარდა
#define MSG_HOTSWAP_FAILED "hotswap connect failed"			// hotswap სერვერთან კავშირი ვერ დამყარდა
#define MSG_STORAGE_ERROR  "something bad happened -- file is corrupt"	// არცერთ სერვერზე არ მოხდა ჰეშების დამთხვევა ეს ნიშნავს რომ ფაილები არავალიდურია
```
ასევე ლოგირება ხდება ჰეშების არ დამთხვევის შემთხვევაში თუ რომელი სერვერიდან ხდება ფაილის აღდგენა
და რომელ სერვერზე ხდება რა ფაილის აღდგენა.


## epoll api

სერვერი connection ების მიღებას აკეთებს epoll-ის საშუალებით. დაცდას აკეთებს EPOLLIN ფლეგით და ელოდება კლიენტს. თუ epoll_wait-მა 0-ზე მეტი დააბრუნა ნიშნავს, რომ კლიენტი დაუკავშირდა და ახალ ნაკადში უშვებს client_handler ფუნქციას.



